<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Lee">







<title>RDG | Lee</title>



    <link rel="icon" href="/favicon.ico">



<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+SC:wght@300;400;500;700&family=Roboto+Mono&display=swap');
</style>



    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    




    <!-- scripts list from _config.yml -->
    
    <script src="/js/frame.js"></script>
    




    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>







  <meta name="generator" content="Hexo 5.4.2"></head>
  <body>
    <div class="mask-border">
    </div>

    <div class="wrapper">

      <div class="header">
  <div class="flex-container">
    <div class="header-inner">
      <div class="site-brand-container">
        <a href="/">
          
            
          
        </a>
      </div>
      <div id="menu-btn" class="menu-btn" onclick="toggleMenu()">
        Menu
      </div>
      <nav class="site-nav">
        <ul class="menu-list">
          
            
              <li class="menu-item">
                <a href="/">Home</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/categories/gallery/">Blog</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/archives/">Archive</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/tag/">Tag</a>
              </li> 
                   
          
            
              <li class="menu-item">
                <a href="/about/">About</a>
              </li> 
                   
          
          
        </ul>
      </nav>
    </div>
  </div>
</div>


      <div class="main">
        <div class="flex-container">
          <article id="post">

  
    <div class="post-head">
    <div class="post-info">
        <div class="tag-list">
            
                
                    <span class="post-tag">
                        <a href="/tags/Render/">
                            Render
                        </a>
                    </span>    
                
                    <span class="post-tag">
                        <a href="/tags/UE5/">
                            UE5
                        </a>
                    </span>    
                           
            
        </div>
        <div class="post-title">
            
            
                RDG
            
            
        </div>
        <span class="post-date">
            Oct 18, 2022
        </span>
    </div>
    <div class="post-img">
        
            <img src="/./images/13.jpg" alt="featured_image">
              
    </div>
</div>
    <div class="post-content">
    <div class="toc">

<!-- toc -->

<ul>
<li><a href="#yi-rdg-rendering-dependency-graph">一-RDG（Rendering Dependency Graph）</a></li>
<li><a href="#er-rdg-ji-chu">二-<strong>RDG基础</strong></a><ul>
<li><a href="#rdg-zi-yuan">RDG资源</a></li>
<li><a href="#rdg-pass"><strong>RDG Pass</strong></a></li>
<li><a href="#frdgbuilder"><strong>FRDGBuilder</strong></a></li>
</ul>
</li>
<li><a href="#san-rdg-ji-zhi"><strong>三-RDG机制</strong></a><ul>
<li><a href="#ji-zhi-gai-shu">机制概述</a></li>
<li><a href="#frdgbuilder-addpass">FRDGBuilder::AddPass</a></li>
<li><a href="#frdgbuilder-compile">FRDGBuilder::Compile</a></li>
<li><a href="#frdgbuilder-execute">FRDGBuilder::Execute</a></li>
<li><a href="#xiao-jie">小结</a></li>
</ul>
</li>
<li><a href="#si-rdg-kai-fa">四-RDG开发</a><ul>
<li><a href="#chuang-jian-rdg-zi-yuan">创建RDG资源</a></li>
<li><a href="#zhu-ce-wai-bu-zi-yuan">注册外部资源</a></li>
<li><a href="#ti-qu-zi-yuan"><strong>提取资源</strong></a></li>
<li><a href="#zeng-jia-pass"><strong>增加Pass</strong></a></li>
<li><a href="#chuang-jian-frdgbuilder"><strong>创建FRDGBuilder</strong></a></li>
<li><a href="#rdg-diao-shi"><strong>RDG调试</strong></a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

</div>

<h2><span id="yi-rdg-rendering-dependency-graph">一-RDG（Rendering Dependency Graph）</span><a href="#yi-rdg-rendering-dependency-graph" class="header-anchor"></a></h2><p>本文摘抄自<a target="_blank" rel="noopener" href="https://www.cnblogs.com/timlly/p/15217090.html">深度剖析虚幻渲染体系-RDG</a></p>
<p>传统的图形API（DirectX 11、OpenGL）要求驱动器调用复杂的启发法，以确定何时以及如何在GPU上执行关键的调度操作。例如清空缓存，管理和再使用内存，执行布局转换等等。由于接口存在即时模式特性，因此需要复杂的记录和状态跟踪才能处理各种极端情况。这些情况最终会对性能产生负面影响，并阻碍并行。</p>
<p>现代的图形API（DirectX 12、Vulkan和Metal 2）与传统图形API不同，将低级GPU管理的负担转移到应用程序。这使得应用程序可以利用渲染管线的高级情境来驱动调度，从而提高性能并且简化渲染堆栈。</p>
<ul>
<li>RDG是基于有向无环图(Directed Acyclic Graph，DAG)的调度系统，用于执行渲染管线的整帧优化，利用现代的图形API（DirectX 12、Vulkan和Metal 2），实现自动异步计算调度以及更高效的内存管理和屏障管理来提升性能。</li>
<li>RDG的理念不在GPU上立即执行Pass，而是先收集所有需要渲染的Pass，然后按照依赖的顺序对图表进行编译和执行，期间会执行各类裁剪和优化。</li>
</ul>
<h2><span id="er-rdg-ji-chu">二-<strong>RDG基础</strong></span><a href="#er-rdg-ji-chu" class="header-anchor"></a></h2><h3><span id="rdg-zi-yuan">RDG资源</span><a href="#rdg-zi-yuan" class="header-anchor"></a></h3><ul>
<li>RDG资源并不是直接用RHI资源，而是包裹了RHI资源引用，然后针对不同类型的资源各自封装，且增加了额外的信息。</li>
<li>在RDG系统中，基本上对所有的RHI资源进行了封装和包裹，以便进一步控制、管理RHI资源，精准控制它们的生命周期、引用关系及调试信息等，进一步可以优化、裁剪它们，提升渲染性能。</li>
</ul>
<h3><span id="rdg-pass"><strong>RDG Pass</strong></span><a href="#rdg-pass" class="header-anchor"></a></h3><ul>
<li><p>以上显示RDG的Pass比较复杂，是RDG体系中最核心的类型之一，涉及了消费者、生产者、转换依赖、各类资源状态等等数据和处理。RDG的Pass有以下几种类型：</p>
<p><img src="./1.png"></p>
</li>
<li><p>RDG Pass和渲染Pass并非一一对应关系，有可能多个合并成一个渲染Pass</p>
</li>
</ul>
<h3><span id="frdgbuilder"><strong>FRDGBuilder</strong></span><a href="#frdgbuilder" class="header-anchor"></a></h3><ul>
<li>FRDGBuilder是RDG体系的心脏和发动机，也是个大管家，负责收集渲染Pass和参数，编译Pass、数据，处理资源依赖，裁剪和优化各类数据，还有提供执行接口。</li>
</ul>
<h2><span id="san-rdg-ji-zhi"><strong>三-RDG机制</strong></span><a href="#san-rdg-ji-zhi" class="header-anchor"></a></h2><h3><span id="ji-zhi-gai-shu">机制概述</span><a href="#ji-zhi-gai-shu" class="header-anchor"></a></h3><p>渲染依赖图框架（Rendering Dependency Graph Framework），它设置Lambda范围，该范围设计为Pass，利用延迟执行向RHI发出GPU命令。它们是通过<code>FRDGBuilder::AddPass()</code>创建的。当创建一个Pass时，它需要Shader参数。 可以是任何着色器参数，但框架最感兴趣的是渲染图形资源。</p>
<p>保存所有Pass参数的结构应该使用<code>FRDGBuilder::AllocParameters()</code>分配，以确保正确的生命周期，因为Lambda的执行是被延迟的。</p>
<p>用<code>FRDGBuilder::CreateTexture()</code>或F<code>RDGBuilder::CreateBuffer()</code>创建的一个渲染图资源只记录资源描述符。当资源需要时，将按图表进行分配。渲染图将跟踪资源的生命周期，并在剩余的Pass不再引用它时释放和重用内存。</p>
<p>Pass使用的所有渲染图资源必须在<code>FRDGBuilder::AddPass()</code>给出的Pass参数中，因为渲染图需要知道每个Pass正在使用哪些资源。</p>
<p>只保证在执行Pass时分配资源。 因此，访问它们应该只在使用<code>FRDGBuilder::AddPass()</code>创建的Pass的Lambda范围内完成。未列出Pass使用的一些资源可能会导致问题。</p>
<p>重要的是不要在参数中引用比Pass需要的更多的图资源，因为这人为地增加了关于该资源生命周期的图信息。这可能会导致内存使用的增加或防止Pass的重叠地执行。一个例子是<code>ClearUnusedGraphResources()</code>，它可以自动清除Shader中没有使用的资源引用。如果资源在Pass中没有被使用，则会发出警告。</p>
<p>Pass执行的lambda范围可能发生在<code>FRDGBuilder::AddPass()</code>之后的任何时候。出于调试的目的，它可能直接发生在具有Immediate模式的<code>AddPass()</code>中。当在传递执行过程中发生错误时，立即模式允许您使用可能包含错误源原因的Pass设置的调用堆栈。Immediate模式可以通过命令行命令<code>-rdgimmediate</code>或控制台变量<code>r.RDG.ImmediateMode=1</code>来启用。</p>
<p>由遗留代码生成的池管理资源纹理FPooledRenderTarget可以通过使用<code>FRDGBuilder::RegisterExternalTexture()</code>在渲染图中使用。</p>
<p>有了Pass依赖关系的信息，执行可能会对不同的硬件目标进行优先级排序，例如对内存压力或Pass GPU执行并发进行优先级排序。因此，不能保证Pass的执行顺序。Pass的执行顺序只能保证将在中间资源上执行工作，就像立即模式在GPU上执行工作一样。</p>
<p>渲染图通道不应该修改外部数据结构的状态，因为这可能会根据Pass的执行顺序导致边界情况。应该使用<code>FRDGBuilder::QueueTextureExtraction()</code>提取执行完成后幸存的渲染图资源(例如viewport back buffer、TAA历史记录…)。如果检测到一个Pass对生成任何计划提取的资源或修改外部纹理没有用处，这个Pass甚至可能不会执行警告。</p>
<p>除非是出于强大的技术原因(比如为VR一次性渲染多个视图的立体渲染)，否则不要在同一Pass中将多个工作捆绑在不同的资源上。这将最终在一组工作上创建更多的依赖关系，单个工作可能只需要这些依赖关系的一个子集。调度程序可能会将其中的一部分与其它GPU工作重叠。这也可能保留分配的瞬态资源更长的时间，潜在地增加整帧的最高内存压力峰值。</p>
<p>虽然<code>AddPass()</code>只希望lambda范围有延迟执行，但这并不意味着我们需要编写一个。通过使用一个更简单的工具箱（如FComputeShaderUtils、FPixelShaderUtils）就可以满足大多数情况的需求了。</p>
<h3><span id="frdgbuilder-addpass">FRDGBuilder::AddPass</span><a href="#frdgbuilder-addpass" class="header-anchor"></a></h3><ul>
<li><p><code>FRDGBuilder::AddPass</code>是向RDG系统增加一个包含Pass参数和Lambda的Pass，其具体的逻辑如下：</p>
</li>
<li><p><code>AddPass</code>会根据传入的参数构建一个RDG Pass的实例，然后设置该Pass的纹理和缓冲区数据，接着用内部设置Pass的依赖Pass等句柄，如果是立即模式，会重定向纹理和缓冲区的Merge状态成Pass状态，并且直接执行</p>
</li>
</ul>
<h3><span id="frdgbuilder-compile">FRDGBuilder::Compile</span><a href="#frdgbuilder-compile" class="header-anchor"></a></h3><ul>
<li>RDG编译期间的逻辑非常复杂，步骤繁多，先后经历构建生产者和消费者的依赖关系，确定Pass的裁剪等各类标记，调整资源的生命周期，裁剪Pass，处理Pass的资源转换和屏障，处理异步计算Pass的依赖和引用关系，查找并建立分叉和合并Pass节点，合并所有具体相同渲染目标的光栅化Pass等步骤</li>
</ul>
<h3><span id="frdgbuilder-execute">FRDGBuilder::Execute</span><a href="#frdgbuilder-execute" class="header-anchor"></a></h3><ul>
<li>在执行过程中涉及到了执行Pass的接口ExecutePass，执行Pass主要有3个步骤：1. prologue、2. pass主体、3. epilogue</li>
<li>执行期间，会先编译所有Pass，然后依次执行Pass的前序、主体和后续，相当于将命令队列的BeginRenderPass、执行渲染代码、EndRenderPass分散在它们之间。Pass执行主体实际很简单，就是调用该Pass的Lambda实例，传入使用的命令队列实例。</li>
</ul>
<h3><span id="xiao-jie">小结</span><a href="#xiao-jie" class="header-anchor"></a></h3><p>UE的RDG体系默认执行于渲染线程，虽然会合并具有相同RT的RDG Pass，但不意味着它们会被并行地执行，而是被串行地执行。在普通情况下，每个Pass执行的末期不会立即提交并等待GPU完成，但如果是调试模式且非异步计算，则会。</p>
<p>FRDGBuilder并没有全局唯一的实例，通常是将它声明为局部变量，在一定生命周期内完成Pass的收集、编译和执行的整套流程。声明FRDGBuilder实例的模块有：距离场、渲染纹理、场景渲染器、场景捕捉器、光线追踪、后处理、毛发、虚拟纹理等等。</p>
<p>FRDGBuilder的执行周期可划分为4个阶段：收集Pass、编译Pass、执行Pass和清理。</p>
<p>收集Pass阶段，主要是收集渲染模块的所有能够产生RHI渲染指令的Pass（Lambda），收集之后并非立即执行，将被延迟执行。AddPass的步骤是先创建FRDGPass的实例，并加入到Pass列表，随后执行SetupPass。SetupPass的过程主要是处理纹理和缓冲区的状态、引用、依赖和标记等。</p>
<p>编译Pass阶段，则比较复杂，步骤甚多。主要包含构建生产者和消费者的依赖关系，确定Pass的裁剪等各类标记，调整资源的生命周期，裁剪Pass，处理Pass的资源转换和屏障，处理异步计算Pass的依赖和引用关系，查找并建立分叉和合并Pass节点，合并所有具体相同渲染目标的光栅化Pass等步骤。</p>
<p>执行Pass阶段，首先会执行编译，再根据编译结果执行所有符合条件的Pass。执行单个Pass时依次执行前序、主体和后续，相当于执行命令队列的BeginRenderPass、执行Pass主体（Lambda）渲染代码、EndRenderPass。执行Pass主体时过程简洁，就是调用该Pass的Lambda实例。</p>
<p>最后便是清理阶段，将清理或重置FRDGBuilder实例内的所有数据和内存。</p>
<h2><span id="si-rdg-kai-fa">四-RDG开发</span><a href="#si-rdg-kai-fa" class="header-anchor"></a></h2><h3><span id="chuang-jian-rdg-zi-yuan">创建RDG资源</span><a href="#chuang-jian-rdg-zi-yuan" class="header-anchor"></a></h3><p>创建RDG资源（纹理、缓冲区、UAV、SRV等）的示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ---- 创建RDG纹理示范 ----</span></span><br><span class="line"><span class="comment">// 创建RDG纹理描述</span></span><br><span class="line">FRDGTextureDesc TextureDesc = Input.Texture-&gt;Desc;</span><br><span class="line">TextureDesc.<span class="built_in">Reset</span>();</span><br><span class="line">TextureDesc.Format = PF_FloatRGBA;</span><br><span class="line">TextureDesc.ClearValue = FClearValueBinding::None;</span><br><span class="line">TextureDesc.Flags &amp;= ~TexCreate_DepthStencilTargetable;</span><br><span class="line">TextureDesc.Flags |= TexCreate_RenderTargetable;</span><br><span class="line">TextureDesc.Extent = OutputViewport.Extent;</span><br><span class="line"><span class="comment">// 创建RDG纹理.</span></span><br><span class="line">FRDGTextureRef MyRDGTexture = GraphBuilder.<span class="built_in">CreateTexture</span>(TextureDesc, <span class="built_in">TEXT</span>(<span class="string">&quot;MyRDGTexture&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 创建RDG纹理UAV示范 ----</span></span><br><span class="line">FRDGTextureUAVRef MyRDGTextureUAV = GraphBuilder.<span class="built_in">CreateUAV</span>(MyRDGTexture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---- 创建RDG纹理SRV示范 ----</span></span><br><span class="line">FRDGTextureSRVRef MyRDGTextureSRV = GraphBuilder.<span class="built_in">CreateSRV</span>(FRDGTextureSRVDesc::<span class="built_in">CreateWithPixelFormat</span>(MyRDGTexture, PF_FloatRGBA));</span><br></pre></td></tr></table></figure>

<p>创建纹理等资源前需要创建资源的描述符，而创建资源的UAV和SRV时，可以用之前创建的资源作为实例传进去，从而达到复用的目的。创建SRV需要将资源实例作为描述符的参数，创建描述符后再创建SRV。</p>
<h3><span id="zhu-ce-wai-bu-zi-yuan">注册外部资源</span><a href="#zhu-ce-wai-bu-zi-yuan" class="header-anchor"></a></h3><p>通过<code>FRDGBuilder::RegisterExternalXXX</code>接口可以完成将外部资源注册到RDG系统中。下面以注册纹理为例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在RDG外创建RHI资源.</span></span><br><span class="line">FRHIResourceCreateInfo CreateInfo;</span><br><span class="line">FTexture2DRHIRef MyRHITexture = <span class="built_in">RHICreateTexture2D</span>(<span class="number">1024</span>, <span class="number">768</span>, PF_B8G8R8A8, <span class="number">1</span>, <span class="number">1</span>, TexCreate_CPUReadback, CreateInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将外部创建的RHI资源注册成RDG资源.</span></span><br><span class="line">FRDGTextureRef MyExternalRDGTexture = GraphBuilder.<span class="built_in">RegisterExternalTexture</span>(MyRHITexture);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，外部注册的资源，RDG无法控制和管理其生命周期，需要保证RDG使用期间外部资源的生命周期处于正常状态，否则将引发异常甚至程序崩溃。</p>
<p>如果想从RDG资源获取RHI资源的实例，以下代码可达成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FRHITexture* MyRHITexture = MyRDGTexture.<span class="built_in">GetRHI</span>();</span><br></pre></td></tr></table></figure>

<p>用图例展示RHI资源和RDG资源之间的转换关系：</p>
<p><img src="./2.png"></p>
<h3><span id="ti-qu-zi-yuan"><strong>提取资源</strong></span><a href="#ti-qu-zi-yuan" class="header-anchor"></a></h3><p>上一章RDG机制中已经提到了，RDG收集Pass之后并非立即执行，而是延迟执行（包括资源被延迟创建或分配），这就导致了一个问题：如果想将渲染后的资源赋值给某个变量，无法使用立即模式，需要适配延迟执行模式。这种适配延迟执行的资源提取是通过以下接口来实现的：</p>
<ul>
<li><p><code>FRDGBuilder::QueueTextureExtraction</code></p>
</li>
<li><p><code>FRDGBuilder::QueueBufferExtraction</code></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建RDG纹理.</span></span><br><span class="line">FRDGTextureRef MyRDGTexture;</span><br><span class="line"></span><br><span class="line">FRDGTextureDesc MyTextureDesc = FRDGTextureDesc::<span class="built_in">Create2D</span>(OutputExtent, HistoryPixelFormat, FClearValueBinding::Black, TexCreate_ShaderResource | TexCreate_UAV);</span><br><span class="line"></span><br><span class="line">MyRDGTexture = GraphBuilder.<span class="built_in">CreateTexture</span>(MyTextureDesc, <span class="string">&quot;MyRDGTexture&quot;</span>, ERDGTextureFlags::MultiFrame);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建UAV并作为Pass的shader参数.</span></span><br><span class="line">(......)</span><br><span class="line">PassParameters-&gt;MyRDGTextureUAV = GraphBuilder.<span class="built_in">CreateUAV</span>(MyRDGTexture);</span><br><span class="line">(......)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加Pass, 以便渲染图像到MyRDGTextureUAV.</span></span><br><span class="line">FComputeShaderUtils::<span class="built_in">AddPass</span>(GraphBuilder, <span class="built_in">RDG_EVENT_NAME</span>(<span class="string">&quot;MyCustomPass&quot;</span>, ...), ComputeShader, PassParameters, FComputeShaderUtils::<span class="built_in">GetGroupCount</span>(<span class="number">8</span>, <span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队提取资源.</span></span><br><span class="line">TRefCountPtr&lt;IPooledRenderTarget&gt;* OutputRT;</span><br><span class="line">GraphBuilder.<span class="built_in">QueueTextureExtraction</span>(MyRDGTexture, &amp;OutputRT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对提取的OutputRT进行后续操作.</span></span><br><span class="line">(......)</span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，由于Pass、资源创建和提取都是被延迟的，意味着提取的资源仅可返回，提供给下一帧使用。</p>
<h3><span id="zeng-jia-pass"><strong>增加Pass</strong></span><a href="#zeng-jia-pass" class="header-anchor"></a></h3><p>整个RDG体系执行的单位是RDG Pass，它们的依赖、引用、输入、输出都是通过FRDGBuilder::AddPass完成，以下是其中一个示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Pass的shader参数.</span></span><br><span class="line">FMyPS::FParameters* PassParameters = GraphBuilder.<span class="built_in">AllocParameters</span>&lt;FMyPS::FParameters&gt;();</span><br><span class="line">PassParameters-&gt;InputTexture = InputTexture;</span><br><span class="line">PassParameters-&gt;RenderTargets = <span class="built_in">FRenderTargetBinding</span>(InputTexture, InputTextureLoadAction);</span><br><span class="line">PassParameters-&gt;InputSampler = BilinearSampler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理着色器.</span></span><br><span class="line"><span class="function">TShaderMapRef&lt;FScreenPassVS&gt; <span class="title">VertexShader</span><span class="params">(View.ShaderMap)</span></span>;</span><br><span class="line"><span class="function">TShaderMapRef&lt;FMyPS&gt; <span class="title">PixelShader</span><span class="params">(View.ShaderMap)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> FScreenPassPipelineState <span class="title">PipelineState</span><span class="params">(VertexShader, PixelShader, AdditiveBlendState)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加RDG Pass.</span></span><br><span class="line">GraphBuilder.<span class="built_in">AddPass</span>(</span><br><span class="line">    <span class="built_in">RDG_EVENT_NAME</span>(<span class="string">&quot;MyRDGPass&quot;</span>),</span><br><span class="line">    PassParameters,</span><br><span class="line">    ERDGPassFlags::Raster,</span><br><span class="line">    <span class="comment">// Pass的Lambda</span></span><br><span class="line">    [PixelShader, PassParameters, PipelineState] (FRHICommandListImmediate&amp; RHICmdList)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置视口.</span></span><br><span class="line">        RHICmdList.<span class="built_in">SetViewport</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0.0f</span>, <span class="number">1024</span>, <span class="number">768</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置PSO.</span></span><br><span class="line">        <span class="built_in">SetScreenPassPipelineState</span>(RHICmdList, PipelineState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置着色器参数.</span></span><br><span class="line">        <span class="built_in">SetShaderParameters</span>(RHICmdList, PixelShader, PixelShader.<span class="built_in">GetPixelShader</span>(), *PassParameters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绘制矩形区域.</span></span><br><span class="line">        <span class="built_in">DrawRectangle</span>(RHICmdList, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1024</span>, <span class="number">768</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="built_in">FIntPoint</span>(<span class="number">1024</span>, <span class="number">768</span>), <span class="built_in">FIntPoint</span>(<span class="number">1024</span>, <span class="number">768</span>), PipelineState.VertexShader, EDRF_Default);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>向RDG系统增加的Pass可以是传统的Graphics Pass，也可以是Compute Shader，还可以是无参数的Pass。RDG Pass和RHI Pass并非一一对应关系，若干个RDG Pass可能合并成一个RHI Pass执行。具体见上一章节<strong>11.3.4 FRDGBuilder::Execute</strong>。</p>
<h3><span id="chuang-jian-frdgbuilder"><strong>创建FRDGBuilder</strong></span><a href="#chuang-jian-frdgbuilder" class="header-anchor"></a></h3><p>创建和使用FRDGBuilder的代码非常简单，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">RenderMyStuff</span><span class="params">(FRHICommandListImmediate&amp; RHICmdList)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ----创建FRDGBuilder的局部对象----</span></span><br><span class="line">    <span class="function">FRDGBuilder <span class="title">GraphBuilder</span><span class="params">(RHICmdList, RDG_EVENT_NAME(<span class="string">&quot;GraphBuilder_RenderMyStuff&quot;</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">    (......)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----增加Pass----</span></span><br><span class="line">    </span><br><span class="line">    GraphBuilder.<span class="built_in">AddPass</span>(...);</span><br><span class="line">    </span><br><span class="line">    (......)</span><br><span class="line">    </span><br><span class="line">    GraphBuilder.<span class="built_in">AddPass</span>(...);</span><br><span class="line">    </span><br><span class="line">    (......)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ----增加资源提取----</span></span><br><span class="line">    </span><br><span class="line">    GraphBuilder.<span class="built_in">QueueTextureExtraction</span>(...);</span><br><span class="line">    </span><br><span class="line">    (......)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ---- 执行FRDGBuilder ----</span></span><br><span class="line">    </span><br><span class="line">    GraphBuilder.<span class="built_in">Execute</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要特别指出的是，FRDGBuilder的实例通常都是局部的，在UE体系中存在若干个FRDGBuilder的实例，主要用于比较独立的模块，例如场景渲染器、后处理、光线追踪等等模块。</p>
<p>FRDGBuilder执行实际有三个步骤：收集Pass、编译Pass、执行Pass，不过<code>FRDGBuilder::Execute</code>已经包含了编译和执行Pass，所以我们不再需要显示地调用<code>FRDGBuilder::Compile</code>接口。</p>
<h3><span id="rdg-diao-shi"><strong>RDG调试</strong></span><a href="#rdg-diao-shi" class="header-anchor"></a></h3><p>RDG系统存在一些控制台命令，其名称和描述如下：</p>
<table>
<thead>
<tr>
<th>控制台变量</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>r.RDG.AsyncCompute</strong></td>
<td>控制异步计算策略：0-禁用；1-为异步计算Pass启用标记（默认）；2-开启所有使用compute命令列表的计算通道。</td>
</tr>
<tr>
<td><strong>r.RDG.Breakpoint</strong></td>
<td>当满足某些条件时，断点到调试器的断点位置。0-禁用，1~4-不同的特殊调试模式。</td>
</tr>
<tr>
<td><strong>r.RDG.ClobberResources</strong></td>
<td>在分配时间用指定的清理颜色清除所有渲染目标和纹理/缓冲UAV。用于调试。</td>
</tr>
<tr>
<td><strong>r.RDG.CullPasses</strong></td>
<td>RDG是否开启裁剪无用的Pass。0-禁用，1-开启（默认）。</td>
</tr>
<tr>
<td><strong>r.RDG.Debug</strong></td>
<td>允许输出在连接和执行过程中发现的效率低下的警告。</td>
</tr>
<tr>
<td><strong>r.RDG.Debug.FlushGPU</strong></td>
<td>开启每次Pass执行后刷新指令到GPU。当设置(r.RDG.AsyncCompute=0)时禁用异步计算。</td>
</tr>
<tr>
<td><strong>r.RDG.Debug.GraphFilter</strong></td>
<td>将某些调试事件过滤到特定的图中。</td>
</tr>
<tr>
<td><strong>r.RDG.Debug.PassFilter</strong></td>
<td>将某些调试事件过滤到特定的Pass。</td>
</tr>
<tr>
<td><strong>r.RDG.Debug.ResourceFilter</strong></td>
<td>将某些调试事件过滤到特定的资源。</td>
</tr>
<tr>
<td><strong>r.RDG.DumpGraph</strong></td>
<td>将多个可视化日志转储到磁盘。0-禁用，1-显示生产者、消费者Pass依赖，2-显示资源状态和转换，3-显示图形、异步计算的重叠。</td>
</tr>
<tr>
<td><strong>r.RDG.ExtendResourceLifetimes</strong></td>
<td>RDG将把资源生命周期扩展到图的全部长度。会增加内存的占用。</td>
</tr>
<tr>
<td><strong>r.RDG.ImmediateMode</strong></td>
<td>在创建Pass时执行Pass。当在Pass的Lambda中崩溃时，连接代码的调用堆栈非常有用。</td>
</tr>
<tr>
<td><strong>r.RDG.MergeRenderPasses</strong></td>
<td>图形将合并相同的、连续的渲染通道到一个单一的渲染通道。0-禁用，1-开启（默认）。</td>
</tr>
<tr>
<td><strong>r.RDG.OverlapUAVs</strong></td>
<td>RDG将在需要时重叠UAV的工作。如果禁用，UAV屏障总是插入。</td>
</tr>
<tr>
<td><strong>r.RDG.TransitionLog</strong></td>
<td>输出资源转换到控制台。</td>
</tr>
<tr>
<td><strong>r.RDG.VerboseCSVStats</strong></td>
<td>控制RDG的CSV分析统计的详细程度。0-为图形执行生成一个CSV配置文件，1-为图形执行的每个阶段生成一个CSV文件。</td>
</tr>
</tbody></table>

</div> 

<script>
    window.onload = detectors();
</script>
    <div class="post-footer">
    <div class="h-line-primary"></div>
    <nav class="post-nav">
        <div class="prev-item">
           
                <div class="icon arrow-left"></div>
                <div class="post-link">
                    <a href="/2022/11/13/1-Math-Matrix-Calculus/">Prev</a>
                </div>
            
        </div>
        <div class="next-item">
            
                <div class="icon arrow-right"></div>
                <div class="post-link">
                  <a href="/2022/10/17/6-Render-UE-RHI/">Next</a>  
                </div>  
            
        </div>
    </nav>
</div>

    
      <div class="post-comment">

     

     
    
    

</div>
     
  
</article>
        </div>
      </div>
      
      <div class="footer">
    <div class="flex-container">
        <div class="footer-text">
            
            
                
        </div>
    </div>
</div>

    </div>

    
    

  </body>
</html>
